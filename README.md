# Advanced Programming Tutorial
## Juan Dharmananda Khusuma - 2206081521

## Module 1
### Reflection 1
> You already implemented two new features using Spring Boot. Check again your source code and evaluate the coding standards that you have learned in this module. Write clean code principles and secure coding practices that have been applied to your code.  If you find any mistake in your source code, please explain how to improve your code. Please write your reflection inside the repository's README.md file.

In my source code, I've implemented several clean code principles and secure coding practices that I've learned in this module. Some of the clean code principles and secure coding practices that I've applied to my code are:
- using meaningful variable names and method names
- using proper indentation and formatting
- adhering to the DRY (Don't Repeat Yourself) principle by reusing the code and creating helper methods such as in the `findProductById` method that is used in `editProduct` and `deleteProduct`
- using proper exception handling and error messages to prevent the site from crashing and to provide a better user experience
- using proper access modifiers for the methods and variables
- processing the user input on the server side to prevent XSS attacks


### Reflection 2
> After writing the unit test, how do you feel? How many unit tests should be made in a class? How to make sure that our unit tests are enough to verify our program? It would be good if you learned about code coverage. Code coverage is a metric that can help you understand how much of your source is tested. If you have 100% code coverage, does that mean your code has no bugs or errors?

After writing the unit test for my code, I'm starting to understand the importance of unit testing. It helps to ensure that the codes that I've written are working as expected and could handle several edge cases that could help prevent and reduce any potential for bugs and errors to appear. In terms of ensuring that our unit test are sufficient, I believe that there should be at least one unit test for each method in a class. However, it would be better if there are more than one unit test for each method, to ensure that the method is working as expected under several scenarios and edge cases. To make sure that our unit tests are enough to verify our program, we can use code coverage. Code coverage is a measurement of how much code are tested by our test suite by checking how many functions and lines of code were ran during the testing process. However, having 100% code coverage doesn't mean that our code has no bugs or errors. It only means that all of our code is tested and executed by the test suite, but it doesn't guarantee that our code is either bug-free or error-free.

> Suppose that after writing the CreateProductFunctionalTest.java along with the corresponding test case, you were asked to create another functional test suite that verifies the number of items in the product list. You decided to create a new Java class similar to the prior functional test suites with the same setup procedures and instance variables. 
What do you think about the cleanliness of the code of the new functional test suite? Will the new code reduce the code quality? Identify the potential clean code issues, explain the reasons, and suggest possible improvements to make the code cleaner! Please write your reflection inside the repository's README.md file.

I believe that the code quality on this new functional test suite would surely decline, since we're breaking the DRY (Don't Repeat Yourself) principle. Any changes or fixes within one of the reused methods would require us to change all of the other methods that are using the same method. This would cause more and more maintanability issues as our codebase grows. To improve the cleanliness of the code, we could use some helper function like the `setUp` with a `@BeforeEach` method to reduce the redundancy of and boilerplate whenever starting a new test. Other possible improvements if the test classes are similiar enough is to use inheritance, where we could create a parent class that contains the `setUp` method and other common methods, and then extend the parent class to the new test classes. This way, we could reduce the redundancy and boilerplate of the code, and also improve the maintainability of the codebase.

## Module 2
### Reflection 1
> List the code quality issue(s) that you fixed during the exercise and explain your strategy on fixing them.
- Added a return to the `deleteProduct` method to return the deleted product. This prevents the user from getting a null response when the product is deleted
- Added a contructor to the 'Product' class to reduce boilerplate. This also reduce redundancy and to avoid the need to call setters for each field repeatedly.
- Added a autogenerated id for the 'Product' class to ensure that each product has a unique id. This also reduces the need to manually set the id for each product.
- Fixed some of the variable names to be more descriptive and meaningful.
- Fixed the indentation and formatting of the code to make it more readable and easier to understand.
- Fixed code repetition for ProductController by setting "redirect:/product/list" as a constant variable.
- Removed the public modifier from product counter to prevent unwanted access to the counter or unexpected changes to the counter.

> Look at your CI/CD workflows (GitHub)/pipelines (GitLab). Do you think the current implementation has met the definition of Continuous Integration and Continuous Deployment? Explain the reasons (minimum 3 sentences)!

I believe that the current implementation has met the definition of Continuous Integration and Continuous Deployment. The reasons are:
- I've implemented a CI/CD workflow using GitHub Actions that automatically runs the test suite using gradle. There is also a workflow that scans the codebase whenever a new commit is pushed to the repository using SonarCloud. This ensures that the codebase is always in a working state and that any new changes won't break the codebase.
- I've also implemented a CD workflow using Koyeb that automatically deploys the application to the cloud whenever a new commit is pushed to the repository.

## Module 3
## Reflection 1
>  Explain what principles you apply to your project!

- Single Responsibility Principle: Refactored the Product model, so it only contains the product's attributes, and moved the instantiation of the product to the ProductRepository. This is due to the Product model responsibility is to only represents the product's data and attributes, while the ProductRepository responsibility is to manage mutation and retrieval of the product data.
- Open/Closed Principle: Created a Repository interface and implemented it with ProductRepository and CartRepository. This allows us to add new repositories that implements the Repository interface without modifying the existing code.
- Interface Segregation Principle: The interface for repositories are split into IRepositoryRead and IRepositoryWrite. This allows us to create a repository that only implements the read or write methods, without having to implement the methods that are not needed. These interface are then combined into a single Repository interface that is could be used by a repository that needs both read and write methods.
- Dependency Inversion Principle: The ProductService, CarService, ProductController, and CarController are now using the Repository interface instead of the ProductRepository and CarRepository directly. This allows us to change the implementation of the repository without having to change the any of the services or controllers.

> Explain the advantages of applying SOLID principles to your project with examples.

The advantages of applying SOLID principles to my project are:
- Single Responsibility Principle: The Product model now only contains the product's attributes, and the instantiation of the product is moved to the ProductRepository. This allows us to separate the concerns of the model and the repository, and makes the codebase more maintainable and easier to understand. Due to this I only need to test the Product instantiation logic in the ProductRepository, and the Product model only needs to be tested for its attributes. This reduces the complexity of the test and makes the test more focused and also reduced the potential for bugs and errors.
- Open/Closed Principle: The Repository interface is now implemented by ProductRepository and CartRepository. This allows us to add new repositories that implements the Repository interface without modifying the existing code. This makes the codebase more maintainable and easier to extend, and also reduces the potential for bugs and errors.
- Interface Segregation Principle: The IRepositoryRead and IRepositoryWrite interfaces are split into two separate interfaces. This allows us to create a repository that only implements the read or write methods, without having to implement the methods that are not needed. This makes the codebase more maintainable and easier to extend, and also reduces the potential for bugs and errors.
- Dependency Inversion Principle: The ProductService, CarService, ProductController, and CarController are now using the Repository interface instead of the ProductRepository and CarRepository directly. This allows us to change the implementation of the repository without having to change the any of the services or controllers. This allows us to decouple the services and controllers from the repository, and makes the codebase more maintainable and easier to extend, and also reduces the potential for bugs and errors.

>  Explain the disadvantages of not applying SOLID principles to your project with examples.

The disadvantages of not applying SOLID principles to my project are:
- Single Responsibility Principle: If the Product model still contains the instantiation of the product, it would be harder to maintain and extend the codebase. This is because the model would have to be tested for the instantiation logic, and the repository would have to be tested for the product's attributes. This would increase the complexity of the test and makes the test less focused, and also increase the potential for bugs and errors.
- Open/Closed Principle: If the Repository interface is not implemented by ProductRepository and CartRepository, it would be harder to maintain and extend the codebase. This is because we would have to modify the existing code whenever we want to add a new repository.
- Interface Segregation Principle: If the IRepositoryRead and IRepositoryWrite interfaces are not split into two separate interfaces, it would be harder to maintain and extend the codebase. This is because we would have to implement the methods that are not needed for a repository. This would make the codebase less maintainable and harder to extend and it might be confusing when trying to test a code that we actually didn't need at all, and it also increase the potential for bugs and errors.
- Dependency Inversion Principle: If the ProductService, CarService, ProductController, and CarController are still using the ProductRepository and CarRepository directly, it would cause the code for services and controllers to be tightly coupled with the repository, and would make the codebase less maintainable and harder to extend, and also increase the potential for bugs and errors.

## Module 4
### Reflection 1

> Reflect based on Percival (2017) proposed self-reflective questions (in “Principles and Best Practice of Testing” submodule, chapter “Evaluating Your Testing Objectives”), whether this TDD flow is useful enough for you or not. If not, explain things that you need to do next time you make more tests.

For me personally, the TDD flow has introduced me to a new way of thinking about testing and has helped me to understand the importance of writing tests before writing the code. It has also helped me to understand the importance of writing tests to ensure that the code is working as expected and to prevent any potential for bugs and errors. Developing with TDD in mind helps me to establish the problem space first before delving into the solution space. This allows me to have a better understanding of the problem and the requirements, and also helps me to write better and more focused tests. However, I believe that I still need to practice more to get used to the TDD flow and to understand the best practices of testing. I also need to learn more about the different types of testing and when to use them, and also about the different testing tools and frameworks that are available.

> You have created unit tests in Tutorial. Now reflect whether your tests have successfully followed F.I.R.S.T. principle or not. If not, explain things that you need to do the next time you create more tests.

I believe that the unit tests that I've created in the tutorial have successfully followed the F.I.R.S.T. principle. The tests are Fast, Independent, Repeatable, Self-Validating, and Timely. The tests are fast because they are running in isolation and are not dependent on any external resources. The tests are independent because they are not dependent on each other and can be run in any order. The tests are repeatable because they are running in isolation and are not dependent on any external resources. The tests are self-validating because they are checking the results of the code that is being tested. The tests are timely because they are written before the code that is being tested. However, I believe that I still need to practice more to get used to the F.I.R.S.T. principle and to understand the best practices of testing. I also need to learn more about the different types of testing and when to use them, and also about the different testing tools and frameworks that are available.